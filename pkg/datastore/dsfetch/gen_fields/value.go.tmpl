{{if not .MaybeType}}
	// {{.TypeName}} is a value from the datastore.
	type {{.TypeName}} struct {
		err      error

		key      dskey.Key
		required bool

		lazies []*{{.GoType}}
		isNull   bool // TODO: Can this be removed?

		fetch *Fetch
	}

	// Value returns the value.
	func (v *{{.TypeName}}) Value(ctx context.Context) ({{.GoType}}, error) {
		if err:=v.err; err != nil {
			return {{.Zero}}, v.err
		}

		rawValue, err := v.fetch.getOneKey(ctx, v.key)
		if err != nil {
			return {{.Zero}}, err
		}

		var value {{.GoType}}
		v.Lazy(&value)

		if err := v.execute(rawValue); err != nil {
			return {{.Zero}}, err
		}

		return value, nil
	}

	// Lazy sets a value as soon as it es executed.
	//
	// Make sure to call request.Execute() before using the value.
	func (v *{{.TypeName}}) Lazy(value *{{.GoType}}) {
		v.fetch.requested[v.key] = append(v.fetch.requested[v.key], v)
		v.lazies = append(v.lazies, value)
	}
{{else}}
	// {{.TypeName}} is a value from the datastore.
	type {{.TypeName}} struct {
		err      error

		key      dskey.Key
		required bool

		lazies []*Maybe[{{.GoType}}]
		isNull   bool // TODO: Can this be removed?

		fetch *Fetch
	}

	// Value returns the value.
	func (v *{{.TypeName}}) Value(ctx context.Context) ({{.GoType}}, bool, error) {
		if err:=v.err; err != nil {
			return {{.Zero}}, false, v.err
		}

		rawValue, err := v.fetch.getOneKey(ctx, v.key)
		if err != nil {
			return {{.Zero}}, false, err
		}

		var value Maybe[{{.GoType}}]
		v.Lazy(&value)

		if err := v.execute(rawValue); err != nil {
			return {{.Zero}}, false, err
		}

		// TODO: Return the Maybe type instead.
		gotValue, gotHasValue := value.Value()
		return gotValue, gotHasValue, nil
	}

	// Lazy sets a value as soon as it es executed.
	//
	// Make sure to call request.Execute() before using the value.
	func (v *{{.TypeName}}) Lazy(value *Maybe[{{.GoType}}]) {
		v.fetch.requested[v.key] = append(v.fetch.requested[v.key], v)
		v.lazies = append(v.lazies, value)
	}
{{end}}


// Preload fetches the value but does nothing with it.
//
// This makes sure, that the value is in the cache.
//
// Make sure to call fetch.Execute().
func (v *{{.TypeName}}) Preload() {
	v.fetch.requested[v.key] = append(v.fetch.requested[v.key], v)
}

// execute will be called from request.
func (v *{{.TypeName}}) execute(p []byte) error {
	{{- if not .MaybeType}}
		var value {{.GoType}}
	{{- else }}
		var value Maybe[{{.GoType}}]
	{{- end }}
	if p == nil {
		if v.required {
			return fmt.Errorf("database is corrupted. Required field %s is null", v.key)
		}
		v.isNull = true
	} else {
		{{- if eq .TypeName "ValueIntSlice"}}
			r, err := fastjson.DecodeIntList(p)
			if err != nil {
				return fmt.Errorf("decoding value %q: %w", p, err)
			}
			value = r
		{{- else if eq .TypeName "ValueInt" }}
			r, err := fastjson.DecodeInt(p)
			if err != nil {
				return fmt.Errorf("decoding value %q: %w", p, err)
			}
			value = r
		{{- else }}
			if err := json.Unmarshal(p, &value); err != nil {
				return fmt.Errorf("decoding value %q: %w", p, err)
			}
		{{- end }}
	}

	for i := 0; i < len(v.lazies); i++ {
		*v.lazies[i] = value
	}

	return nil
}
