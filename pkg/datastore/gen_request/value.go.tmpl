// {{.TypeName}} is a lazy value from the datastore.
type {{.TypeName}} struct {
	value    {{.GoType}}
	isNull   bool
	executed bool

	lazies []*{{.GoType}}

	request *Request
}

// Value returns the value.
func (v *{{.TypeName}}) Value(ctx context.Context) ({{.GoType}}, error) {
	if v.request.err != nil {
		return {{.Zero}}, v.request.err
	}

	if v.executed {
		return v.value, nil
	}

	if err := v.request.Execute(ctx); err != nil {
		return {{.Zero}}, fmt.Errorf("executing request: %w", err)
	}

	return v.value, nil
}

// Lazy sets a value as soon as it es executed.
//
// Make sure to call request.Execute() before using the value.
func (v *{{.TypeName}}) Lazy(value *{{.GoType}}) {
	v.lazies = append(v.lazies, value)
}

// ErrorLater is like Value but does not return an error.
//
// If an error happs, it is saved internaly. Make sure to call request.Err() later to
// access it.
func (v *{{.TypeName}}) ErrorLater(ctx context.Context) {{.GoType}} {
	if v.request.err != nil {
		return {{.Zero}}
	}

	if v.executed {
		return v.value
	}

	if err := v.request.Execute(ctx); err != nil {
		return {{.Zero}}
	}

	return v.value
}

// execute will be called from request.
func (v *{{.TypeName}}) execute(p []byte) error {
	{{- if eq .TypeName  "ValueIDSlice"}}
		var values []string
		if err := json.Unmarshal(p, &values); err != nil {
			return fmt.Errorf("decoding value %q: %v", p, err)
		}

		for _, e := range values {
			i, err := strconv.Atoi(e)
			if err != nil {
				return fmt.Errorf("converting value %q: %w", e, err)
			}
			v.value = append(v.value, i)
		}
	{{- else}}
		if err := json.Unmarshal(p, &v.value); err != nil {
			return fmt.Errorf("decoding value %q: %v", p, err)
		}
	{{- end}}

	for i := 0; i < len(v.lazies); i++ {
		*v.lazies[i] = v.value
	}

	v.executed = true
	return nil
}
